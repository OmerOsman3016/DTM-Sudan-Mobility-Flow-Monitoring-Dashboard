<!DOCTYPE html>
<html lang="en" data-app="sudan-mobility-flow-monitoring">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Sudan — Mobility Flow Monitoring Dashboard (IOM)</title>

  <!-- ======== CDNs ======== -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer"/>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <!-- ======== STYLE (IOM look & modern UI) ======== -->
  <style>
    :root{
      /* Brand */
      --iom-blue:#0033A0;          /* IOM deep blue */
      --iom-blue-accent:#418FDE;   /* IOM accent */
      --mint:#5CB8B2;              /* accent 2 */
      --yellow:#FFB81C;            /* KPI highlight */
      --red:#D22630;               /* alert */
      --bg:#0f172a;                /* slate-900 */
      --panel:#111827;             /* gray-900 */
      --muted:#94a3b8;             /* slate-400 */
      --text:#e5e7eb;              /* gray-200 */
      --chip:#1f2937;              /* gray-800 */
      --card:#0b1223;              /* dark card */
      --border:#1f2a44;            /* subtle border */
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      margin:0; background:linear-gradient(180deg, #0b1223 0%, #0f172a 100%); color:var(--text);
    }
    header{
      position:sticky; top:0; z-index:20; backdrop-filter: blur(6px);
      background:rgba(11,18,35,.8); border-bottom:1px solid var(--border);
    }
    .topbar{display:flex; align-items:center; gap:16px; padding:14px 18px;}
    .brand{display:flex; align-items:center; gap:12px}
    .brand .logo{width:36px; height:36px; border-radius:9px; background:conic-gradient(from 210deg, var(--iom-blue), var(--iom-blue-accent)); box-shadow:0 0 0 2px #0b1223, 0 6px 18px rgba(65,143,222,.25)}
    .brand h1{font-size:18px; margin:0; font-weight:800; letter-spacing:.2px}
    .sub{font-size:12px; color:var(--muted); font-weight:500}

    main{max-width:1400px; margin:18px auto; padding:0 16px 80px}

    /* Filters */
    .filters{display:grid; grid-template-columns:repeat(12,1fr); gap:12px; margin:16px 0 10px}
    .filter{
      grid-column: span 3;
      background:var(--panel); border:1px solid var(--border); border-radius:14px; padding:10px 12px;
    }
    .filter label{display:block; font-size:12px; color:var(--muted); margin-bottom:6px}
    .filter select, .filter input{
      width:100%; background:var(--chip); color:var(--text); border:1px solid var(--border);
      padding:8px 10px; border-radius:10px; outline:none;
    }
    .filter small{display:block; color:var(--muted); margin-top:6px}
    .controls{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
    .btn{background:var(--iom-blue-accent); color:#fff; border:0; padding:9px 12px; border-radius:10px; cursor:pointer; font-weight:600}
    .btn.secondary{background:#1f2937}
    .btn.ghost{background:transparent; border:1px solid var(--border)}

    /* KPI cards */
    .kpis{display:grid; grid-template-columns:repeat(12,1fr); gap:12px; margin:14px 0 24px}
    .kpi{grid-column:span 4; background:linear-gradient(180deg, #0b1223, #0f172a); border:1px solid var(--border); border-radius:16px; padding:14px; position:relative; overflow:hidden}
    .kpi h3{margin:0; font-size:12px; color:var(--muted); font-weight:600}
    .kpi .value{font-size:28px; font-weight:800; margin-top:6px}
    .kpi .badge{position:absolute; right:12px; top:12px; background:var(--chip); color:var(--muted); padding:4px 8px; border-radius:999px; font-size:11px; border:1px solid var(--border)}

    /* Grid sections */
    .grid{display:grid; grid-template-columns:repeat(12,1fr); gap:12px}
    .card{grid-column:span 6; background:var(--card); border:1px solid var(--border); border-radius:16px; padding:12px}
    .card h4{margin:0 0 8px; font-size:14px; font-weight:800}
    .card .subtle{font-size:12px; color:var(--muted); margin-left:6px}
    .card .chart{height:280px}

    .footer{margin-top:28px; color:var(--muted); font-size:12px; text-align:center}

    @media (max-width: 1100px){
      .filter{grid-column:span 6}
      .kpi{grid-column:span 6}
      .card{grid-column:span 12}
    }
    @media (max-width: 640px){
      .filter{grid-column:span 12}
    }
  </style>
</head>
<body>
  <header>
    <div class="topbar">
      <div class="brand">
        <div class="logo" aria-hidden="true"></div>
        <div>
          <h1>Sudan — Mobility Flow Monitoring</h1>
          <div class="sub">Indicative dashboard for FMC (flows) + FMS (survey). Configurable to your CSVs.</div>
        </div>
      </div>
      <div class="controls" style="margin-left:auto">
        <button id="btn-export" class="btn ghost" title="Export current aggregates (CSV)"><i class="fa-solid fa-file-arrow-down"></i>&nbsp;Export CSV</button>
        <button id="btn-reset" class="btn secondary" title="Reset filters"><i class="fa-solid fa-rotate"></i>&nbsp;Reset</button>
      </div>
    </div>
  </header>

  <main>
    <!-- ========== FILTERS ========== -->
    <section class="filters" id="filters">
      <div class="filter"><label>CBP</label>
        <select id="f-cbp"></select>
      </div>
      <div class="filter"><label>Direction</label>
        <select id="f-direction">
          <option value="all">All</option>
          <option value="incoming">Incoming</option>
          <option value="outgoing">Outgoing</option>
        </select>
      </div>
      <div class="filter"><label>Nationality</label>
        <select id="f-nationality"></select>
      </div>
      <div class="filter"><label>Gender</label>
        <select id="f-gender"></select>
      </div>
      <div class="filter"><label>Date From</label>
        <input id="f-date-from" type="date" />
        <small id="f-date-from-summary"></small>
      </div>
      <div class="filter"><label>Date To</label>
        <input id="f-date-to" type="date" />
        <small id="f-date-to-summary"></small>
      </div>
      <div class="filter" style="grid-column:span 12">
        <label style="display:flex;align-items:center;gap:8px">Quick filters
          <span class="subtle">(applies to all cards)</span></label>
        <div class="controls">
          <button class="btn" id="btn-apply">Apply</button>
          <button class="btn ghost" id="btn-last30">Last 30 days</button>
          <button class="btn ghost" id="btn-thisMonth">This month</button>
          <button class="btn ghost" id="btn-clearDates">Clear dates</button>
        </div>
      </div>
    </section>

    <!-- ========== KPIs ========== -->
    <section class="kpis">
      <div class="kpi" id="kpi-total">
        <div class="badge">Total flows</div>
        <h3>All directions</h3>
        <div class="value" id="kpi-total-value">0</div>
      </div>
      <div class="kpi" id="kpi-in">
        <div class="badge">Inflow</div>
        <h3>Incoming</h3>
        <div class="value" id="kpi-in-value">0</div>
      </div>
      <div class="kpi" id="kpi-out">
        <div class="badge">Outflow</div>
        <h3>Outgoing</h3>
        <div class="value" id="kpi-out-value">0</div>
      </div>
    </section>

    <!-- ========== CHARTS GRID ========== -->
    <section class="grid" id="charts-grid">
      <div class="card" style="grid-column:span 12">
        <h4>Timeline <span class="subtle">(daily totals, split by direction)</span></h4>
        <canvas id="chart_timeline" class="chart"></canvas>
      </div>

      <div class="card">
        <h4>Gender</h4>
        <canvas id="chart_gender" class="chart"></canvas>
      </div>
      <div class="card">
        <h4>Age groups</h4>
        <canvas id="chart_age" class="chart"></canvas>
      </div>

      <div class="card">
        <h4>Transport</h4>
        <canvas id="chart_transport" class="chart"></canvas>
      </div>
      <div class="card">
        <h4>Nationality (Top 10)</h4>
        <canvas id="chart_nationality" class="chart"></canvas>
      </div>

      <div class="card">
        <h4>Documents possessed (Top 10)</h4>
        <canvas id="chart_documents" class="chart"></canvas>
      </div>
      <div class="card">
        <h4>Vulnerabilities (Top 10)</h4>
        <canvas id="chart_vulnerability" class="chart"></canvas>
      </div>

      <div class="card">
        <h4>State of origin (Top 10)</h4>
        <canvas id="chart_state_origin" class="chart"></canvas>
      </div>
      <div class="card">
        <h4>Destination (Top 10)</h4>
        <canvas id="chart_destination" class="chart"></canvas>
      </div>

      <div class="card">
        <h4>Main reasons to leave Sudan (Top 10)</h4>
        <canvas id="chart_reason_leave" class="chart"></canvas>
      </div>
      <div class="card">
        <h4>Reasons to travel back to Sudan (Top 10)</h4>
        <canvas id="chart_reason_return" class="chart"></canvas>
      </div>

      <div class="card" style="grid-column:span 12">
        <h4>Movement intentions in the next 3 months</h4>
        <canvas id="chart_intentions" class="chart"></canvas>
      </div>
    </section>

    <div class="footer" id="footer">Ready. Load your CSVs in <code>/data</code> then refresh.</div>
  </main>

  <!-- ======== APP SCRIPT ======== -->
  <script>
    /* =============================================================
       README / HOW TO USE
       -------------------------------------------------------------
       1) Place two CSV files inside your repo's /data folder:
          - flows.csv   (FMC counts)
          - survey.csv  (FMS interviews)

          You can rename them in CONFIG.paths below.

       2) Expected columns (auto-detection is included for common names):
          FLOWS (FMC):
            date, cbp (or CBP Name), direction (incoming/outgoing), volume
          SURVEY (FMS):
            date, cbp, direction, gender, age, transport, nationality,
            documents (multi-select), vulnerability (multi-select),
            state_origin, reason_leave, reason_return, intentions, destination

          Multi-select answers can be numeric codes spaced like "1 3 5"
          or labels like "Passport National ID". A mapping for documents is
          included below.

       3) Open index.html via a local server (needed to fetch CSV):
            python -m http.server 8000
            # then visit http://localhost:8000

       4) On GitHub Pages, ensure CSV files are at /data/*.csv

       5) If your column names differ, extend the SYNONYMS map below
          or set explicit names in CONFIG.columns.
       ============================================================= */

    const CONFIG = {
      paths: {
        flows: 'data/flows.csv',
        survey: 'data/survey.csv'
      },
      columns: {
        flows: { date:'', cbp:'', direction:'', volume:'' }, // leave blank for autodetect
        survey:{
          date:'', cbp:'', direction:'', gender:'', age:'', transport:'', nationality:'',
          documents:'', vulnerability:'', state_origin:'', reason_leave:'', reason_return:'', intentions:'', destination:''
        }
      },
      multi: {
        delimiter: /[;,|\s]+/, // split on space/comma/semicolon/pipe
        documentsMap: { // numeric -> label mapping (edit as needed)
          '1':'Passport','2':'National ID','3':'Birth certificate(s)','4':'Refugee card','5':'Proof of registration','6':'Asylum seeker certificate','7':'None'
        }
      }
    };

    const SYNONYMS = {
      date:['date','submission_date','submissiondate','end','_submission_time','_submission_time_utc','Start','start','visit_date','interview_date','collection_date'],
      cbp:['cbp','cbp_name','CBP Name','borderpoint','border_point','border point','Cross border Name','Cross-border Name','bp_name'],
      direction:['direction','dircation','flow_direction','inout','incoming_outgoing','dir'],
      volume:['volume','count','flows','flow','n','total','total_flow','Daily count','Daily flow'],
      gender:['gender','sex','respondent_gender','sex_of_respondent'],
      age:['age','resp_age','respondent_age','age_group','agegroup'],
      transport:['transport','mode','mode_of_transport','Transport used'],
      nationality:['nationality','nat','country_of_citizenship'],
      documents:['documents','docs','Which of the following documents do you currently possess? (Select all that apply)','docs_possessed','doc_possessed'],
      vulnerability:['vulnerability','vulnerabilities','vuln','specific_vulnerabilities'],
      state_origin:['state_origin','state of origin','origin_state','State of Origin','state'],
      reason_leave:['reason_leave','main reasons for you to leave Sudan','reason to leave','push_factors'],
      reason_return:['reason_return','reasons to travel back to sudan','pull_factors_return'],
      intentions:['intentions','movement intentions in the next three months','movement intentions'],
      destination:['destination','intended_destination','dest','where are you going','final_destination']
    };

    // Global state
    const State = {
      flowsRaw: [],
      surveyRaw: [],
      flows: [],
      survey: [],
      cols: {flows:{}, survey:{}},
      filters: { cbp:'all', direction:'all', nationality:'all', gender:'all', from:'', to:'' },
      charts: {}
    };

    // Utils
    const fmtInt = n => (isFinite(n) ? n.toLocaleString('en-GB') : '0');
    const toDate = v => {
      if (!v) return null;
      const d = new Date(v);
      return isNaN(d) ? null : d;
    };
    const ymd = d => d.toISOString().slice(0,10);
    const norm = v => (v==null? '': String(v).trim());
    const canon = v => norm(v).toLowerCase();

    function detectColumns(rows, wanted){
      if (!rows.length) return {};
      const headers = Object.keys(rows[0]);
      const map = {};
      for (const key in wanted){
        const syns = SYNONYMS[key]||[];
        const explicit = CONFIG.columns[wanted === CONFIG.columns.flows ? 'flows':'survey'][key];
        if (explicit) { map[key]=explicit; continue; }
        // exact match first
        let found = headers.find(h => canon(h)===canon(key));
        if (!found){
          for (const s of syns){
            found = headers.find(h => canon(h)===canon(s) || canon(h).includes(canon(s)));
            if (found) break;
          }
        }
        map[key] = found || '';
      }
      return map;
    }

    function normalizeFlows(rows, cols){
      const out = [];
      for (const r of rows){
        const d = toDate(r[cols.date]);
        if (!d) continue;
        const dirRaw = canon(r[cols.direction]);
        const direction = dirRaw.includes('out')? 'outgoing' : (dirRaw.includes('in')? 'incoming' : (dirRaw === '2' ? 'outgoing' : (dirRaw === '1' ? 'incoming' : 'unknown')));
        const volume = Number(r[cols.volume]) || 0;
        const cbp = norm(r[cols.cbp])||'Unknown CBP';
        out.push({date:d, direction, volume, cbp});
      }
      return out;
    }

    function normalizeSurvey(rows, cols){
      const out = [];
      for (const r of rows){
        const d = toDate(r[cols.date] || r[cols.date]?.split('T')[0]);
        if (!d) continue;
        const cbp = norm(r[cols.cbp])||'Unknown CBP';
        const direction = canon(r[cols.direction]).includes('out')? 'outgoing' : (canon(r[cols.direction]).includes('in')? 'incoming' : 'unknown');
        const gender = tidyLabel(r[cols.gender]);
        const age = tidyLabel(r[cols.age]);
        const transport = tidyLabel(r[cols.transport]);
        const nationality = tidyLabel(r[cols.nationality]);
        const documents = splitMulti(r[cols.documents]).map(tidyLabel);
        const vulnerability = splitMulti(r[cols.vulnerability]).map(tidyLabel);
        const state_origin = tidyLabel(r[cols.state_origin]);
        const reason_leave = splitMulti(r[cols.reason_leave]).map(tidyLabel);
        const reason_return = splitMulti(r[cols.reason_return]).map(tidyLabel);
        const intentions = tidyLabel(r[cols.intentions]);
        const destination = tidyLabel(r[cols.destination]);
        out.push({date:d, cbp, direction, gender, age, transport, nationality, documents, vulnerability, state_origin, reason_leave, reason_return, intentions, destination});
      }
      return out;
    }

    function tidyLabel(v){
      const s = norm(v);
      if (!s) return 'Unknown';
      // Map numeric docs codes to labels when column is documents (handled separately for multi)
      return toTitle(s.replace(/_/g,' '));
    }
    function toTitle(s){
      return s.toLowerCase().replace(/\b\w/g, c=>c.toUpperCase());
    }
    function splitMulti(v){
      if (!v) return [];
      const raw = String(v).trim();
      if (!raw) return [];
      const parts = raw.split(CONFIG.multi.delimiter).filter(Boolean);
      // Map numeric codes for documents specifically
      return parts.map(p => CONFIG.multi.documentsMap[p] || p);
    }

    function applyFilters(){
      const {cbp, direction, nationality, gender, from, to} = State.filters;
      const dateIn = d => (!from || d>=from) && (!to || d<=to);

      State.flows = State.flowsRaw.filter(r => dateIn(r.date) && (cbp==='all'||r.cbp===cbp) && (direction==='all'||r.direction===direction));

      State.survey = State.surveyRaw.filter(r => dateIn(r.date) && (cbp==='all'||r.cbp===cbp) && (direction==='all'||r.direction===direction)
        && (nationality==='all'||r.nationality===nationality) && (gender==='all'||r.gender===gender));
    }

    function uniq(arr){ return [...new Set(arr)]; }

    function groupSum(arr, keyFn, valFn){
      const map = new Map();
      for (const a of arr){
        const k = keyFn(a);
        const v = valFn(a);
        map.set(k, (map.get(k)||0) + v);
      }
      return Array.from(map, ([k,v])=>({key:k, value:v}))
                  .sort((a,b)=> b.value-a.value);
    }

    function groupCount(arr, keyFn){
      return groupSum(arr, keyFn, _=>1);
    }

    function countMulti(arr, key){
      const map = new Map();
      for (const a of arr){
        const items = a[key]||[];
        for (const it of items){
          const label = tidyLabel(it);
          map.set(label, (map.get(label)||0)+1);
        }
      }
      return Array.from(map, ([k,v])=>({key:k, value:v})).sort((a,b)=>b.value-a.value);
    }

    // ---------- Charts ----------
    function ensureChart(id, type, data, options){
      const el = document.getElementById(id);
      if (State.charts[id]){
        State.charts[id].data = data;
        State.charts[id].options = options || State.charts[id].options;
        State.charts[id].update();
        return State.charts[id];
      }
      const ctx = el.getContext('2d');
      const chart = new Chart(ctx, {type, data, options});
      State.charts[id] = chart;
      return chart;
    }

    function palette(n){
      // Let Chart.js pick defaults; here we just produce n placeholders if needed.
      return Array.from({length:n}, (_,i)=>undefined);
    }

    function updateKpis(){
      const total = State.flows.reduce((s,r)=>s+r.volume,0);
      const inSum = State.flows.filter(r=>r.direction==='incoming').reduce((s,r)=>s+r.volume,0);
      const outSum = State.flows.filter(r=>r.direction==='outgoing').reduce((s,r)=>s+r.volume,0);
      document.getElementById('kpi-total-value').textContent = fmtInt(total);
      document.getElementById('kpi-in-value').textContent = fmtInt(inSum);
      document.getElementById('kpi-out-value').textContent = fmtInt(outSum);
    }

    function updateTimeline(){
      const byDayIn = groupSum(State.flows.filter(r=>r.direction==='incoming'), r=>ymd(r.date), r=>r.volume);
      const byDayOut= groupSum(State.flows.filter(r=>r.direction==='outgoing'), r=>ymd(r.date), r=>r.volume);
      const labels = uniq([...byDayIn.map(d=>d.key), ...byDayOut.map(d=>d.key)]).sort();
      const mapIn = new Map(byDayIn.map(d=>[d.key,d.value]));
      const mapOut= new Map(byDayOut.map(d=>[d.key,d.value]));
      const dsIn = labels.map(l=>mapIn.get(l)||0);
      const dsOut= labels.map(l=>mapOut.get(l)||0);
      ensureChart('chart_timeline','line',{
        labels,
        datasets:[
          {label:'Incoming', data:dsIn, tension:.2, fill:false},
          {label:'Outgoing', data:dsOut, tension:.2, fill:false}
        ]
      },{
        responsive:true,
        plugins:{ legend:{position:'top'}, tooltip:{mode:'index', intersect:false}},
        interaction:{mode:'index', intersect:false},
        scales:{ x:{ grid:{display:false}}, y:{ beginAtZero:true} }
      });
    }

    function topN(arr,n=10){ return arr.slice(0,n); }

    function updateCharts(){
      // Gender
      const gender = groupCount(State.survey, r=>r.gender);
      ensureChart('chart_gender','doughnut',{
        labels: gender.map(d=>d.key),
        datasets:[{data:gender.map(d=>d.value)}]
      },{plugins:{legend:{position:'bottom'}}});

      // Age
      const age = groupCount(State.survey, r=>r.age);
      ensureChart('chart_age','bar',{
        labels: age.map(d=>d.key),
        datasets:[{label:'Respondents', data:age.map(d=>d.value)}]
      },{scales:{y:{beginAtZero:true}}});

      // Transport
      const transport = groupCount(State.survey, r=>r.transport);
      ensureChart('chart_transport','bar',{
        labels: transport.map(d=>d.key),
        datasets:[{label:'Respondents', data:transport.map(d=>d.value)}]
      },{scales:{y:{beginAtZero:true}}});

      // Nationality
      const nationality = topN(groupCount(State.survey, r=>r.nationality));
      ensureChart('chart_nationality','bar',{
        labels: nationality.map(d=>d.key),
        datasets:[{label:'Respondents', data:nationality.map(d=>d.value)}]
      },{scales:{y:{beginAtZero:true}}});

      // Documents (multi)
      const documents = topN(countMulti(State.survey,'documents'));
      ensureChart('chart_documents','bar',{
        labels: documents.map(d=>d.key),
        datasets:[{label:'Responses', data:documents.map(d=>d.value)}]
      },{indexAxis:'y', scales:{x:{beginAtZero:true}}});

      // Vulnerability (multi)
      const vulnerability = topN(countMulti(State.survey,'vulnerability'));
      ensureChart('chart_vulnerability','bar',{
        labels: vulnerability.map(d=>d.key),
        datasets:[{label:'Responses', data:vulnerability.map(d=>d.value)}]
      },{indexAxis:'y', scales:{x:{beginAtZero:true}}});

      // State of origin
      const origin = topN(groupCount(State.survey, r=>r.state_origin));
      ensureChart('chart_state_origin','bar',{
        labels: origin.map(d=>d.key),
        datasets:[{label:'Respondents', data:origin.map(d=>d.value)}]
      },{scales:{y:{beginAtZero:true}}});

      // Destination
      const dest = topN(groupCount(State.survey, r=>r.destination));
      ensureChart('chart_destination','bar',{
        labels: dest.map(d=>d.key),
        datasets:[{label:'Respondents', data:dest.map(d=>d.value)}]
      },{scales:{y:{beginAtZero:true}}});

      // Reasons leave/return (multi)
      const rLeave = topN(countMulti(State.survey,'reason_leave'));
      ensureChart('chart_reason_leave','bar',{
        labels: rLeave.map(d=>d.key),
        datasets:[{label:'Mentions', data:rLeave.map(d=>d.value)}]
      },{indexAxis:'y', scales:{x:{beginAtZero:true}}});

      const rReturn = topN(countMulti(State.survey,'reason_return'));
      ensureChart('chart_reason_return','bar',{
        labels: rReturn.map(d=>d.key),
        datasets:[{label:'Mentions', data:rReturn.map(d=>d.value)}]
      },{indexAxis:'y', scales:{x:{beginAtZero:true}}});

      // Intentions
      const intent = groupCount(State.survey, r=>r.intentions);
      ensureChart('chart_intentions','bar',{
        labels: intent.map(d=>d.key),
        datasets:[{label:'Respondents', data:intent.map(d=>d.value)}]
      },{scales:{y:{beginAtZero:true}}});
    }

    function setFilterOptions(){
      const cbps = ['all', ...uniq(State.flowsRaw.map(r=>r.cbp).concat(State.surveyRaw.map(r=>r.cbp))).filter(Boolean)];
      fillSelect('f-cbp', cbps);

      const nats = ['all', ...uniq(State.surveyRaw.map(r=>r.nationality)).filter(Boolean)];
      fillSelect('f-nationality', nats);

      const genders = ['all', ...uniq(State.surveyRaw.map(r=>r.gender)).filter(Boolean)];
      fillSelect('f-gender', genders);

      const dates = uniq(State.flowsRaw.map(r=>ymd(r.date)).concat(State.surveyRaw.map(r=>ymd(r.date)))).sort();
      if (dates.length){
        const min = dates[0], max = dates[dates.length-1];
        const fFrom = document.getElementById('f-date-from');
        const fTo = document.getElementById('f-date-to');
        fFrom.min=min; fFrom.max=max; fTo.min=min; fTo.max=max; fFrom.value=''; fTo.value='';
        document.getElementById('f-date-from-summary').textContent = `min ${min}`;
        document.getElementById('f-date-to-summary').textContent = `max ${max}`;
      }
    }

    function fillSelect(id, options){
      const el = document.getElementById(id);
      el.innerHTML = '';
      for (const opt of options){
        const o = document.createElement('option');
        o.value = opt; o.textContent = toTitle(String(opt));
        el.appendChild(o);
      }
      el.value = options[0];
    }

    function readFilters(){
      const cbp = document.getElementById('f-cbp').value;
      const direction = document.getElementById('f-direction').value;
      const nationality = document.getElementById('f-nationality').value;
      const gender = document.getElementById('f-gender').value;
      const fromRaw = document.getElementById('f-date-from').value;
      const toRaw = document.getElementById('f-date-to').value;
      State.filters = {
        cbp, direction, nationality, gender,
        from: fromRaw? new Date(fromRaw+'T00:00:00Z'): '',
        to: toRaw? new Date(toRaw+'T23:59:59Z'): ''
      };
    }

    function exportAggregates(){
      // Build a simple CSV with key aggregates from current selection
      const total = State.flows.reduce((s,r)=>s+r.volume,0);
      const byDir = groupSum(State.flows, r=>r.direction, r=>r.volume);
      const gender = groupCount(State.survey, r=>r.gender);
      const age = groupCount(State.survey, r=>r.age);
      const transport = groupCount(State.survey, r=>r.transport);
      const nationality = groupCount(State.survey, r=>r.nationality);

      let csv = 'Metric,Category,Value\n';
      csv += `Total flows,All,${total}\n`;
      for (const d of byDir) csv += `Flows by direction,${d.key},${d.value}\n`;
      for (const d of gender) csv += `Gender,${d.key},${d.value}\n`;
      for (const d of age) csv += `Age,${d.key},${d.value}\n`;
      for (const d of transport) csv += `Transport,${d.key},${d.value}\n`;
      for (const d of nationality) csv += `Nationality,${d.key},${d.value}\n`;

      const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href=url; a.download=`aggregates_${Date.now()}.csv`; a.click();
      URL.revokeObjectURL(url);
    }

    async function loadCsv(path){
      return new Promise((resolve, reject) => {
        Papa.parse(path, {
          header:true, dynamicTyping:false, skipEmptyLines:true, download:true,
          complete: results => resolve(results.data),
          error: err => reject(err)
        });
      });
    }

    function footer(msg){ document.getElementById('footer').textContent = msg; }

    async function init(){
      footer('Loading CSVs…');
      try {
        const [flowsRaw, surveyRaw] = await Promise.all([
          loadCsv(CONFIG.paths.flows).catch(()=>[]),
          loadCsv(CONFIG.paths.survey).catch(()=>[])
        ]);
        if (!flowsRaw.length && !surveyRaw.length){
          footer('No data found. Please add /data/flows.csv and /data/survey.csv');
          return;
        }

        // Detect columns
        const flowsCols = detectColumns(flowsRaw, CONFIG.columns.flows);
        const surveyCols= detectColumns(surveyRaw, CONFIG.columns.survey);
        State.cols.flows = flowsCols; State.cols.survey = surveyCols;

        // Normalize
        State.flowsRaw = normalizeFlows(flowsRaw, {date:flowsCols.date||guess('date', flowsRaw), cbp:flowsCols.cbp||guess('cbp', flowsRaw), direction:flowsCols.direction||guess('direction', flowsRaw), volume:flowsCols.volume||guess('volume', flowsRaw)});
        State.surveyRaw= normalizeSurvey(surveyRaw, {date:surveyCols.date||guess('date', surveyRaw), cbp:surveyCols.cbp||guess('cbp', surveyRaw), direction:surveyCols.direction||guess('direction', surveyRaw), gender:surveyCols.gender||guess('gender', surveyRaw), age:surveyCols.age||guess('age', surveyRaw), transport:surveyCols.transport||guess('transport', surveyRaw), nationality:surveyCols.nationality||guess('nationality', surveyRaw), documents:surveyCols.documents||guess('documents', surveyRaw), vulnerability:surveyCols.vulnerability||guess('vulnerability', surveyRaw), state_origin:surveyCols.state_origin||guess('state_origin', surveyRaw), reason_leave:surveyCols.reason_leave||guess('reason_leave', surveyRaw), reason_return:surveyCols.reason_return||guess('reason_return', surveyRaw), intentions:surveyCols.intentions||guess('intentions', surveyRaw), destination:surveyCols.destination||guess('destination', surveyRaw)});

        // If flows missing, derive from survey counts (unweighted)
        if (!State.flowsRaw.length && State.surveyRaw.length){
          const byDayDir = groupSum(State.surveyRaw, r=>ymd(r.date)+"|"+r.direction, _=>1);
          State.flowsRaw = byDayDir.map(d=>{
            const [day, dir] = d.key.split('|');
            return {date:new Date(day), direction:dir, volume:d.value, cbp:'All CBPs'};
          });
        }

        setFilterOptions();
        readFilters();
        applyFilters();
        updateKpis();
        updateTimeline();
        updateCharts();
        footer(`Loaded ${fmtInt(State.flowsRaw.length)} flow rows & ${fmtInt(State.surveyRaw.length)} survey rows · Updated ${new Date().toLocaleString()}`);
      } catch (e){
        console.error(e);
        footer('Error loading data. Open Console for details.');
      }
    }

    function guess(key, rows){
      const headers = rows.length? Object.keys(rows[0]) : [];
      const syn = SYNONYMS[key]||[];
      const all = [key, ...syn];
      const found = headers.find(h => all.some(s => canon(h)===canon(s) || canon(h).includes(canon(s))));
      return found || '';
    }

    // Events
    document.getElementById('btn-apply').addEventListener('click', ()=>{ readFilters(); applyFilters(); updateKpis(); updateTimeline(); updateCharts(); });
    document.getElementById('btn-reset').addEventListener('click', ()=>{
      State.filters = {cbp:'all', direction:'all', nationality:'all', gender:'all', from:'', to:''};
      setFilterOptions(); readFilters(); applyFilters(); updateKpis(); updateTimeline(); updateCharts();
    });
    document.getElementById('btn-last30').addEventListener('click', ()=>{
      const to = new Date(); const from = new Date(Date.now()-29*24*3600*1000);
      document.getElementById('f-date-from').value = ymd(from);
      document.getElementById('f-date-to').value = ymd(to);
      readFilters(); applyFilters(); updateKpis(); updateTimeline(); updateCharts();
    });
    document.getElementById('btn-thisMonth').addEventListener('click', ()=>{
      const now = new Date(); const from = new Date(now.getFullYear(), now.getMonth(), 1);
      const to = new Date(now.getFullYear(), now.getMonth()+1, 0);
      document.getElementById('f-date-from').value = ymd(from);
      document.getElementById('f-date-to').value = ymd(to);
      readFilters(); applyFilters(); updateKpis(); updateTimeline(); updateCharts();
    });
    document.getElementById('btn-clearDates').addEventListener('click', ()=>{
      document.getElementById('f-date-from').value = '';
      document.getElementById('f-date-to').value = '';
      readFilters(); applyFilters(); updateKpis(); updateTimeline(); updateCharts();
    });
    document.getElementById('btn-export').addEventListener('click', exportAggregates);

    // Kick off
    init();
  </script>
</body>
</html>
